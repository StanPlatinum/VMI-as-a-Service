/* AUTOGENERATED by libxl_save_msgs_gen.pl DO NOT EDIT */

#include "libxl_osdeps.h"

#include <assert.h>
#include <string.h>
#include <stdint.h>
#include <limits.h>

#include "_libxl_save_msgs_helper.h"
#include <xenctrl.h>
#include <xenguest.h>

static void bytes_put(unsigned char *const buf, int *len,
		      const void *value, int vlen)
{
    assert(vlen < INT_MAX/2 - *len);
    if (buf)
	memcpy(buf + *len, value, vlen);
    *len += vlen;
}

static void int_put(unsigned char *const buf, int *len,
			 const int value)
{
    bytes_put(buf, len, &value, sizeof(value));
}

static void uint16_t_put(unsigned char *const buf, int *len,
			 const uint16_t value)
{
    bytes_put(buf, len, &value, sizeof(value));
}

static void uint32_t_put(unsigned char *const buf, int *len,
			 const uint32_t value)
{
    bytes_put(buf, len, &value, sizeof(value));
}

static void unsigned_put(unsigned char *const buf, int *len,
			 const unsigned value)
{
    bytes_put(buf, len, &value, sizeof(value));
}

static void unsigned_long_put(unsigned char *const buf, int *len,
			 const unsigned long value)
{
    bytes_put(buf, len, &value, sizeof(value));
}

static void BLOCK_put(unsigned char *const buf,
                      int *len,
		      const uint8_t *bytes, uint32_t size)
{
    uint32_t_put(buf, len, size);
    bytes_put(buf, len, bytes, size);
}

static void STRING_put(unsigned char *const buf,
		       int *len,
		       const char *string)
{
    size_t slen = strlen(string);
    assert(slen < INT_MAX / 4);
    assert(slen < (uint32_t)0x40000000);
    BLOCK_put(buf, len, (const void*)string, slen+1);
}

void helper_stub_log(uint32_t level, uint32_t errnoval, const char *context, const char *formatted, void *user)
{
    unsigned char *buf = 0;
    int len = 0, allocd = 0;

    for (;;) {
        uint16_t_put(buf, &len, 1 /* log */);
	uint32_t_put(buf, &len, level);
	uint32_t_put(buf, &len, errnoval);
	STRING_put(buf, &len, context);
	STRING_put(buf, &len, formatted);
        if (buf) break;
        buf = helper_allocbuf(len, user);
        assert(buf);
        allocd = len;
        len = 0;
    }
    assert(len == allocd);
    helper_transmitmsg(buf, len, user);
}

void helper_stub_progress(const char *context, const char *doing_what, unsigned long done, unsigned long total, void *user)
{
    unsigned char *buf = 0;
    int len = 0, allocd = 0;

    for (;;) {
        uint16_t_put(buf, &len, 2 /* progress */);
	STRING_put(buf, &len, context);
	STRING_put(buf, &len, doing_what);
	unsigned_long_put(buf, &len, done);
	unsigned_long_put(buf, &len, total);
        if (buf) break;
        buf = helper_allocbuf(len, user);
        assert(buf);
        allocd = len;
        len = 0;
    }
    assert(len == allocd);
    helper_transmitmsg(buf, len, user);
}

int helper_stub_suspend(void *user)
{
    unsigned char *buf = 0;
    int len = 0, allocd = 0;

    for (;;) {
        uint16_t_put(buf, &len, 3 /* suspend */);
        if (buf) break;
        buf = helper_allocbuf(len, user);
        assert(buf);
        allocd = len;
        len = 0;
    }
    assert(len == allocd);
    helper_transmitmsg(buf, len, user);
    int r = helper_getreply(user);
    return r;
}

void helper_setcallbacks_save(struct save_callbacks *cbs, unsigned cbflags)
{
    cbs->suspend = (cbflags & (1u<<3)) ? helper_stub_suspend : 0;
    cbs->postcopy = (cbflags & (1u<<4)) ? helper_stub_postcopy : 0;
    cbs->checkpoint = (cbflags & (1u<<5)) ? helper_stub_checkpoint : 0;
    cbs->switch_qemu_logdirty = (cbflags & (1u<<6)) ? helper_stub_switch_qemu_logdirty : 0;
}

int helper_stub_postcopy(void *user)
{
    unsigned char *buf = 0;
    int len = 0, allocd = 0;

    for (;;) {
        uint16_t_put(buf, &len, 4 /* postcopy */);
        if (buf) break;
        buf = helper_allocbuf(len, user);
        assert(buf);
        allocd = len;
        len = 0;
    }
    assert(len == allocd);
    helper_transmitmsg(buf, len, user);
    int r = helper_getreply(user);
    return r;
}

int helper_stub_checkpoint(void *user)
{
    unsigned char *buf = 0;
    int len = 0, allocd = 0;

    for (;;) {
        uint16_t_put(buf, &len, 5 /* checkpoint */);
        if (buf) break;
        buf = helper_allocbuf(len, user);
        assert(buf);
        allocd = len;
        len = 0;
    }
    assert(len == allocd);
    helper_transmitmsg(buf, len, user);
    int r = helper_getreply(user);
    return r;
}

void helper_setcallbacks_restore(struct restore_callbacks *cbs, unsigned cbflags)
{
    cbs->checkpoint = (cbflags & (1u<<5)) ? helper_stub_checkpoint : 0;
}

int helper_stub_switch_qemu_logdirty(int domid, unsigned enable, void *user)
{
    unsigned char *buf = 0;
    int len = 0, allocd = 0;

    for (;;) {
        uint16_t_put(buf, &len, 6 /* switch_qemu_logdirty */);
	int_put(buf, &len, domid);
	unsigned_put(buf, &len, enable);
        if (buf) break;
        buf = helper_allocbuf(len, user);
        assert(buf);
        allocd = len;
        len = 0;
    }
    assert(len == allocd);
    helper_transmitmsg(buf, len, user);
    int r = helper_getreply(user);
    return r;
}

void helper_stub_restore_results(unsigned long store_mfn, unsigned long console_mfn, void *user)
{
    unsigned char *buf = 0;
    int len = 0, allocd = 0;

    for (;;) {
        uint16_t_put(buf, &len, 7 /* restore_results */);
	unsigned_long_put(buf, &len, store_mfn);
	unsigned_long_put(buf, &len, console_mfn);
        if (buf) break;
        buf = helper_allocbuf(len, user);
        assert(buf);
        allocd = len;
        len = 0;
    }
    assert(len == allocd);
    helper_transmitmsg(buf, len, user);
}

int helper_stub_complete(int retval, int errnoval, void *user)
{
    unsigned char *buf = 0;
    int len = 0, allocd = 0;

    for (;;) {
        uint16_t_put(buf, &len, 8 /* complete */);
	int_put(buf, &len, retval);
	int_put(buf, &len, errnoval);
        if (buf) break;
        buf = helper_allocbuf(len, user);
        assert(buf);
        allocd = len;
        len = 0;
    }
    assert(len == allocd);
    helper_transmitmsg(buf, len, user);
    int r = helper_getreply(user);
    return r;
}

